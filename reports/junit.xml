<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="435" failures="0" errors="0" time="6.772">
  <testsuite name="TextTool Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.72" tests="6">
    <testcase classname="TextTool Component debería llamar a updateElementStyles al cambiar la alineación del texto" name="TextTool Component debería llamar a updateElementStyles al cambiar la alineación del texto" time="0.084">
    </testcase>
    <testcase classname="TextTool Component debería llamar a updateElementStyles al cambiar el estilo del texto (ej. negrita)" name="TextTool Component debería llamar a updateElementStyles al cambiar el estilo del texto (ej. negrita)" time="0.023">
    </testcase>
    <testcase classname="TextTool Component Funcionalidad de Listas debería convertir texto plano a una lista de viñetas" name="TextTool Component Funcionalidad de Listas debería convertir texto plano a una lista de viñetas" time="0.025">
    </testcase>
    <testcase classname="TextTool Component Funcionalidad de Listas debería convertir una lista de viñetas a texto plano (toggle)" name="TextTool Component Funcionalidad de Listas debería convertir una lista de viñetas a texto plano (toggle)" time="0.036">
    </testcase>
    <testcase classname="TextTool Component Funcionalidad de Listas debería llamar a updateElementStyles al cambiar el tamaño de la fuente" name="TextTool Component Funcionalidad de Listas debería llamar a updateElementStyles al cambiar el tamaño de la fuente" time="0.021">
    </testcase>
    <testcase classname="TextTool Component Funcionalidad de Listas debería llamar a updateElementStyles al cambiar el color del texto" name="TextTool Component Funcionalidad de Listas debería llamar a updateElementStyles al cambiar el color del texto" time="0.042">
    </testcase>
  </testsuite>
  <testsuite name="UserModal Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.769" tests="5">
    <testcase classname="UserModal Component debería renderizar el título y los campos del formulario" name="UserModal Component debería renderizar el título y los campos del formulario" time="0.048">
    </testcase>
    <testcase classname="UserModal Component debería actualizar el estado al interactuar con los campos de texto" name="UserModal Component debería actualizar el estado al interactuar con los campos de texto" time="0.006">
    </testcase>
    <testcase classname="UserModal Component debería llamar a onSave pero no despachar si la validación falla" name="UserModal Component debería llamar a onSave pero no despachar si la validación falla" time="0.047">
    </testcase>
    <testcase classname="UserModal Component Flujo de Creación de Usuario debería despachar la acción createUserManagement con el payload correcto" name="UserModal Component Flujo de Creación de Usuario debería despachar la acción createUserManagement con el payload correcto" time="0.021">
    </testcase>
    <testcase classname="UserModal Component Flujo de Creación de Usuario debería manejar un error de la API y mostrar una notificación" name="UserModal Component Flujo de Creación de Usuario debería manejar un error de la API y mostrar una notificación" time="0.021">
    </testcase>
  </testsuite>
  <testsuite name="Preview Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.83" tests="6">
    <testcase classname="Preview Component debería renderizar las páginas y los elementos de los contextos" name="Preview Component debería renderizar las páginas y los elementos de los contextos" time="0.046">
    </testcase>
    <testcase classname="Preview Component debería llamar a updatePages al hacer clic en &quot;Agregar página&quot;" name="Preview Component debería llamar a updatePages al hacer clic en &quot;Agregar página&quot;" time="0.067">
    </testcase>
    <testcase classname="Preview Component debería llamar a updatePages y clearPageItems al eliminar una página" name="Preview Component debería llamar a updatePages y clearPageItems al eliminar una página" time="0.019">
    </testcase>
    <testcase classname="Preview Component Submisión de Formato debería mostrar un toast de error si la validación falla" name="Preview Component Submisión de Formato debería mostrar un toast de error si la validación falla" time="0.016">
    </testcase>
    <testcase classname="Preview Component Submisión de Formato debería despachar la acción &quot;createFormat&quot; si es un formato nuevo" name="Preview Component Submisión de Formato debería despachar la acción &quot;createFormat&quot; si es un formato nuevo" time="0.044">
    </testcase>
    <testcase classname="Preview Component Submisión de Formato debería despachar la acción &quot;updateFormat&quot; si se está editando un formato" name="Preview Component Submisión de Formato debería despachar la acción &quot;updateFormat&quot; si se está editando un formato" time="0.025">
    </testcase>
  </testsuite>
  <testsuite name="SidebarOption Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.83" tests="11">
    <testcase classname="SidebarOption Component debería llamar a handleClickElement directamente si el &quot;element&quot; está limpio" name="SidebarOption Component debería llamar a handleClickElement directamente si el &quot;element&quot; está limpio" time="0.063">
    </testcase>
    <testcase classname="SidebarOption Component debería mostrar el modal si el &quot;element&quot; tiene contenido" name="SidebarOption Component debería mostrar el modal si el &quot;element&quot; tiene contenido" time="0.023">
    </testcase>
    <testcase classname="SidebarOption Component debería mostrar el modal si la condición &quot;content&quot; se cumple" name="SidebarOption Component debería mostrar el modal si la condición &quot;content&quot; se cumple" time="0.015">
    </testcase>
    <testcase classname="SidebarOption Component debería mostrar el modal si la condición &quot;image&quot; se cumple" name="SidebarOption Component debería mostrar el modal si la condición &quot;image&quot; se cumple" time="0.014">
    </testcase>
    <testcase classname="SidebarOption Component debería mostrar el modal si la condición &quot;body cells&quot; se cumple" name="SidebarOption Component debería mostrar el modal si la condición &quot;body cells&quot; se cumple" time="0.019">
    </testcase>
    <testcase classname="SidebarOption Component debería mostrar el modal si la condición &quot;header columns &gt; 1&quot; se cumple" name="SidebarOption Component debería mostrar el modal si la condición &quot;header columns &gt; 1&quot; se cumple" time="0.014">
    </testcase>
    <testcase classname="SidebarOption Component debería mostrar el modal si la condición &quot;style properties &gt; 2&quot; se cumple" name="SidebarOption Component debería mostrar el modal si la condición &quot;style properties &gt; 2&quot; se cumple" time="0.011">
    </testcase>
    <testcase classname="SidebarOption Component debería llamar a handleClickElement al confirmar el modal" name="SidebarOption Component debería llamar a handleClickElement al confirmar el modal" time="0.031">
    </testcase>
    <testcase classname="SidebarOption Component debería cerrar el modal al cancelarlo" name="SidebarOption Component debería cerrar el modal al cancelarlo" time="0.026">
    </testcase>
    <testcase classname="SidebarOption Component debería aplicar estilos de &quot;seleccionado&quot; si el tipo de elemento del contexto coincide" name="SidebarOption Component debería aplicar estilos de &quot;seleccionado&quot; si el tipo de elemento del contexto coincide" time="0.003">
    </testcase>
    <testcase classname="SidebarOption Component debería aplicar estilos normales si el tipo de elemento no coincide" name="SidebarOption Component debería aplicar estilos normales si el tipo de elemento no coincide" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="UserRoles Page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.804" tests="4">
    <testcase classname="UserRoles Page debería renderizar el título y despachar la acción inicial de carga de datos" name="UserRoles Page debería renderizar el título y despachar la acción inicial de carga de datos" time="0.052">
    </testcase>
    <testcase classname="UserRoles Page debería despachar la acción de búsqueda al hacer clic en &quot;Consultar&quot;" name="UserRoles Page debería despachar la acción de búsqueda al hacer clic en &quot;Consultar&quot;" time="0.113">
    </testcase>
    <testcase classname="UserRoles Page Callback onUpdateRow debería mostrar una notificación de error si la descripción está vacía" name="UserRoles Page Callback onUpdateRow debería mostrar una notificación de error si la descripción está vacía" time="0.038">
    </testcase>
    <testcase classname="UserRoles Page Callback onUpdateRow debería despachar la acción &quot;updateRole&quot; con las propiedades modificadas" name="UserRoles Page Callback onUpdateRow debería despachar la acción &quot;updateRole&quot; con las propiedades modificadas" time="0.019">
    </testcase>
  </testsuite>
  <testsuite name="Table.Header (Object Manage) Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.88" tests="8">
    <testcase classname="Table.Header (Object Manage) Component debería renderizar el número correcto de celdas de encabezado (th)" name="Table.Header (Object Manage) Component debería renderizar el número correcto de celdas de encabezado (th)" time="0.054">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component debería aplicar la clase de selección si una celda está en &quot;selectedCells&quot;" name="Table.Header (Object Manage) Component debería aplicar la clase de selección si una celda está en &quot;selectedCells&quot;" time="0.007">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component debería llamar a handleUpdateHeaderCell al escribir en un input" name="Table.Header (Object Manage) Component debería llamar a handleUpdateHeaderCell al escribir en un input" time="0.008">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component debería llamar a handleCellClick al hacer clic en una celda o al enfocar un input" name="Table.Header (Object Manage) Component debería llamar a handleCellClick al hacer clic en una celda o al enfocar un input" time="0.034">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell al presionar el mouse sobre una celda" name="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell al presionar el mouse sobre una celda" time="0.004">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a getHorizontalSelection y setSelectedCells al arrastrar sobre otra celda" name="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a getHorizontalSelection y setSelectedCells al arrastrar sobre otra celda" time="0.002">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) NO debería llamar a la lógica de selección si no se está arrastrando (draggingCell es null)" name="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) NO debería llamar a la lógica de selección si no se está arrastrando (draggingCell es null)" time="0.004">
    </testcase>
    <testcase classname="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell con null al soltar el mouse" name="Table.Header (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell con null al soltar el mouse" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="CreateDataModal Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="1.882" tests="3">
    <testcase classname="CreateDataModal Component debería renderizar en modo &quot;Crear&quot; y mostrar error si los campos están vacíos" name="CreateDataModal Component debería renderizar en modo &quot;Crear&quot; y mostrar error si los campos están vacíos" time="0.124">
    </testcase>
    <testcase classname="CreateDataModal Component debería renderizar en modo &quot;Modificar&quot; y despachar la carga de datos inicial" name="CreateDataModal Component debería renderizar en modo &quot;Modificar&quot; y despachar la carga de datos inicial" time="0.004">
    </testcase>
    <testcase classname="CreateDataModal Component debería despachar la acción de crear y cerrar el modal en caso de éxito" name="CreateDataModal Component debería despachar la acción de crear y cerrar el modal en caso de éxito" time="0.136">
    </testcase>
  </testsuite>
  <testsuite name="UserManagement Page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="2.231" tests="6">
    <testcase classname="UserManagement Page debería renderizar el título y despachar las acciones iniciales de carga de datos" name="UserManagement Page debería renderizar el título y despachar las acciones iniciales de carga de datos" time="0.094">
    </testcase>
    <testcase classname="UserManagement Page debería abrir el modal de &quot;Crear&quot; al hacer clic en el botón" name="UserManagement Page debería abrir el modal de &quot;Crear&quot; al hacer clic en el botón" time="0.083">
    </testcase>
    <testcase classname="UserManagement Page debería despachar la acción de búsqueda al hacer clic en &quot;Consultar&quot;" name="UserManagement Page debería despachar la acción de búsqueda al hacer clic en &quot;Consultar&quot;" time="0.132">
    </testcase>
    <testcase classname="UserManagement Page Callback onUpdateRow debería mostrar un toast de error si la validación de campos vacíos falla" name="UserManagement Page Callback onUpdateRow debería mostrar un toast de error si la validación de campos vacíos falla" time="0.008">
    </testcase>
    <testcase classname="UserManagement Page Callback onUpdateRow debería despachar la acción &quot;modifyUserManagement&quot; en una actualización exitosa" name="UserManagement Page Callback onUpdateRow debería despachar la acción &quot;modifyUserManagement&quot; en una actualización exitosa" time="0.006">
    </testcase>
    <testcase classname="UserManagement Page Callback onUpdateRow debería mostrar un toast de error si la API falla al actualizar" name="UserManagement Page Callback onUpdateRow debería mostrar un toast de error si la API falla al actualizar" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="Sidebar" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:04" time="2.309" tests="3">
    <testcase classname="Sidebar muestra el submenu al hacer clic en una sesión" name="Sidebar muestra el submenu al hacer clic en una sesión" time="0.049">
    </testcase>
    <testcase classname="Sidebar Navegación Link" name="Sidebar Navegación Link" time="0.013">
    </testcase>
    <testcase classname="Sidebar Abre automaticamente la sesión activa si la ruta coincide con el useLocation" name="Sidebar Abre automaticamente la sesión activa si la ruta coincide con el useLocation" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="CreateDataModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:05" time="0.969" tests="2">
    <testcase classname="CreateDataModal muestra validación y NO crea cuando hasEmptyFields=true" name="CreateDataModal muestra validación y NO crea cuando hasEmptyFields=true" time="0.057">
    </testcase>
    <testcase classname="CreateDataModal crea cuando hasEmptyFields=false y flujo fulfilled" name="CreateDataModal crea cuando hasEmptyFields=false y flujo fulfilled" time="0.015">
    </testcase>
  </testsuite>
  <testsuite name="Modal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.844" tests="4">
    <testcase classname="Modal renderiza título y children" name="Modal renderiza título y children" time="0.034">
    </testcase>
    <testcase classname="Modal muestra botones por defecto y dispara onClose / onSave" name="Modal muestra botones por defecto y dispara onClose / onSave" time="0.013">
    </testcase>
    <testcase classname="Modal respeta saveButtonText" name="Modal respeta saveButtonText" time="0.008">
    </testcase>
    <testcase classname="Modal oculta zona de botones si noButtons=true" name="Modal oculta zona de botones si noButtons=true" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="ManageContentProduct page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.886" tests="1">
    <testcase classname="ManageContentProduct page monta, lista, abre modal y elimina" name="ManageContentProduct page monta, lista, abre modal y elimina" time="0.068">
    </testcase>
  </testsuite>
  <testsuite name="ProductManagement page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:05" time="0.933" tests="1">
    <testcase classname="ProductManagement page Funcionamiento consultar y crear" name="ProductManagement page Funcionamiento consultar y crear" time="0.155">
    </testcase>
  </testsuite>
  <testsuite name="Table Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.942" tests="6">
    <testcase classname="Table Component debería llamar a setElement 2 veces si el &quot;element&quot; prop no tiene body o header" name="Table Component debería llamar a setElement 2 veces si el &quot;element&quot; prop no tiene body o header" time="0.031">
    </testcase>
    <testcase classname="Table Component debería mostrar el Toolbar cuando se selecciona una celda" name="Table Component debería mostrar el Toolbar cuando se selecciona una celda" time="0.005">
    </testcase>
    <testcase classname="Table Component no debería mostrar Toolbar ni iconos en modo previsualización" name="Table Component no debería mostrar Toolbar ni iconos en modo previsualización" time="0.002">
    </testcase>
    <testcase classname="Table Component debería mostrar iconos de añadir si no está en modo previsualización" name="Table Component debería mostrar iconos de añadir si no está en modo previsualización" time="0.002">
    </testcase>
    <testcase classname="Table Component debería llamar a handleAddColumn y handleAddRow al hacer clic en los iconos" name="Table Component debería llamar a handleAddColumn y handleAddRow al hacer clic en los iconos" time="0.046">
    </testcase>
    <testcase classname="Table Component Toolbar recibe props correctas" name="Table Component Toolbar recibe props correctas" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="Table Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:05" time="0.994" tests="6">
    <testcase classname="Table Component debe renderizar Header y Body con props correctos" name="Table Component debe renderizar Header y Body con props correctos" time="0.01">
    </testcase>
    <testcase classname="Table Component debe mostrar mensaje cuando no hay resultados y search.showMessage=true" name="Table Component debe mostrar mensaje cuando no hay resultados y search.showMessage=true" time="0.003">
    </testcase>
    <testcase classname="Table Component no debe mostrar mensaje si hay resultados" name="Table Component no debe mostrar mensaje si hay resultados" time="0.002">
    </testcase>
    <testcase classname="Table Component debe renderizar Paginator si data.pages &gt; MinPage" name="Table Component debe renderizar Paginator si data.pages &gt; MinPage" time="0.003">
    </testcase>
    <testcase classname="Table Component no debe renderizar Paginator si data.pages &lt;= MinPage" name="Table Component no debe renderizar Paginator si data.pages &lt;= MinPage" time="0.003">
    </testcase>
    <testcase classname="Table Component debe aplicar wrapperClassName correctamente" name="Table Component debe aplicar wrapperClassName correctamente" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="Input" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:05" time="1.22" tests="4">
    <testcase classname="Input Campo Editable" name="Input Campo Editable" time="0.029">
    </testcase>
    <testcase classname="Input Campo no Editable" name="Input Campo no Editable" time="0.003">
    </testcase>
    <testcase classname="Input llama al handleChange cuando se escribe en el campo" name="Input llama al handleChange cuando se escribe en el campo" time="0.004">
    </testcase>
    <testcase classname="select Validación mapeo de Select" name="select Validación mapeo de Select" time="0.112">
    </testcase>
  </testsuite>
  <testsuite name="ProductInput page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.829" tests="1">
    <testcase classname="ProductInput page renderiza, elimina y muestra notificación" name="ProductInput page renderiza, elimina y muestra notificación" time="0.058">
    </testcase>
  </testsuite>
  <testsuite name="useToast Hook" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.785" tests="5">
    <testcase classname="useToast Hook should initialize with a null toast" name="useToast Hook should initialize with a null toast" time="0.014">
    </testcase>
    <testcase classname="useToast Hook should show a toast with a message and type when toggleToast is called" name="useToast Hook should show a toast with a message and type when toggleToast is called" time="0.003">
    </testcase>
    <testcase classname="useToast Hook should hide the toast if toggleToast is called when a toast is already active" name="useToast Hook should hide the toast if toggleToast is called when a toast is already active" time="0.007">
    </testcase>
    <testcase classname="useToast Hook should override the type to Error if the message is REQUIRED_FIELDS" name="useToast Hook should override the type to Error if the message is REQUIRED_FIELDS" time="0.003">
    </testcase>
    <testcase classname="useToast Hook should hide the toast when toggleToast is called with a null message" name="useToast Hook should hide the toast when toggleToast is called with a null message" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="Table.Body (Object Manage) Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.375" tests="8">
    <testcase classname="Table.Body (Object Manage) Component debería renderizar el número correcto de filas y celdas" name="Table.Body (Object Manage) Component debería renderizar el número correcto de filas y celdas" time="0.033">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component debería aplicar la clase de selección si una celda está en &quot;selectedCells&quot;" name="Table.Body (Object Manage) Component debería aplicar la clase de selección si una celda está en &quot;selectedCells&quot;" time="0.003">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component debería llamar a handleUpdateBodyCell al escribir en un input" name="Table.Body (Object Manage) Component debería llamar a handleUpdateBodyCell al escribir en un input" time="0.005">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component debería llamar a handleCellClick al hacer clic en una celda o al enfocar un input" name="Table.Body (Object Manage) Component debería llamar a handleCellClick al hacer clic en una celda o al enfocar un input" time="0.018">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell al presionar el mouse sobre una celda" name="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell al presionar el mouse sobre una celda" time="0.003">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a getHorizontalSelection y setSelectedCells al arrastrar sobre otra celda en la misma fila" name="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a getHorizontalSelection y setSelectedCells al arrastrar sobre otra celda en la misma fila" time="0.002">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) NO debería llamar a getHorizontalSelection si se arrastra a una fila diferente" name="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) NO debería llamar a getHorizontalSelection si se arrastra a una fila diferente" time="0.003">
    </testcase>
    <testcase classname="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell con null al soltar el mouse" name="Table.Body (Object Manage) Component Lógica de Selección por Arrastre (Drag) debería llamar a setDraggingCell con null al soltar el mouse" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="CreateFileUploadModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.355" tests="3">
    <testcase classname="CreateFileUploadModal muestra mensaje de requeridos si faltan datos" name="CreateFileUploadModal muestra mensaje de requeridos si faltan datos" time="0.02">
    </testcase>
    <testcase classname="CreateFileUploadModal envía createFile y cierra con éxito" name="CreateFileUploadModal envía createFile y cierra con éxito" time="0.067">
    </testcase>
    <testcase classname="CreateFileUploadModal muestra error si backend falla" name="CreateFileUploadModal muestra error si backend falla" time="0.014">
    </testcase>
  </testsuite>
  <testsuite name="MultiSelect Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.443" tests="6">
    <testcase classname="MultiSelect Component debería renderizar el label y el placeholder si no hay opciones seleccionadas" name="MultiSelect Component debería renderizar el label y el placeholder si no hay opciones seleccionadas" time="0.017">
    </testcase>
    <testcase classname="MultiSelect Component debería mostrar las descripciones de las opciones seleccionadas unidas por comas" name="MultiSelect Component debería mostrar las descripciones de las opciones seleccionadas unidas por comas" time="0.004">
    </testcase>
    <testcase classname="MultiSelect Component debería abrir el menú desplegable al hacer clic y cerrarlo al volver a hacer clic" name="MultiSelect Component debería abrir el menú desplegable al hacer clic y cerrarlo al volver a hacer clic" time="0.04">
    </testcase>
    <testcase classname="MultiSelect Component debería cerrar el menú al hacer clic fuera del componente" name="MultiSelect Component debería cerrar el menú al hacer clic fuera del componente" time="0.026">
    </testcase>
    <testcase classname="MultiSelect Component debería llamar a handleChangeOption al hacer clic en una opción" name="MultiSelect Component debería llamar a handleChangeOption al hacer clic en una opción" time="0.03">
    </testcase>
    <testcase classname="MultiSelect Component debería mostrar las opciones correctas como seleccionadas (checked)" name="MultiSelect Component debería mostrar las opciones correctas como seleccionadas (checked)" time="0.021">
    </testcase>
  </testsuite>
  <testsuite name="FontSizeSelector Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.538" tests="7">
    <testcase classname="FontSizeSelector Component debería renderizar el placeholder cuando el valor es un string vacío" name="FontSizeSelector Component debería renderizar el placeholder cuando el valor es un string vacío" time="0.03">
    </testcase>
    <testcase classname="FontSizeSelector Component debería mostrar el label del valor seleccionado" name="FontSizeSelector Component debería mostrar el label del valor seleccionado" time="0.003">
    </testcase>
    <testcase classname="FontSizeSelector Component debería abrir y cerrar el menú desplegable al hacer clic" name="FontSizeSelector Component debería abrir y cerrar el menú desplegable al hacer clic" time="0.055">
    </testcase>
    <testcase classname="FontSizeSelector Component debería llamar a onChangeOption con la opción seleccionada al hacer clic en un item" name="FontSizeSelector Component debería llamar a onChangeOption con la opción seleccionada al hacer clic en un item" time="0.023">
    </testcase>
    <testcase classname="FontSizeSelector Component debería filtrar las opciones al escribir en el input de búsqueda" name="FontSizeSelector Component debería filtrar las opciones al escribir en el input de búsqueda" time="0.039">
    </testcase>
    <testcase classname="FontSizeSelector Component debería crear y seleccionar una nueva opción numérica si no existe" name="FontSizeSelector Component debería crear y seleccionar una nueva opción numérica si no existe" time="0.045">
    </testcase>
    <testcase classname="FontSizeSelector Component debería seleccionar una opción existente si el valor custom coincide con una" name="FontSizeSelector Component debería seleccionar una opción existente si el valor custom coincide con una" time="0.045">
    </testcase>
  </testsuite>
  <testsuite name="ExecutionAssistedProcessModal Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.499" tests="3">
    <testcase classname="ExecutionAssistedProcessModal Component debería mostrar un error de validación si los campos requeridos están vacíos al guardar" name="ExecutionAssistedProcessModal Component debería mostrar un error de validación si los campos requeridos están vacíos al guardar" time="0.042">
    </testcase>
    <testcase classname="ExecutionAssistedProcessModal Component debería despachar la acción y cerrar el modal en un envío exitoso" name="ExecutionAssistedProcessModal Component debería despachar la acción y cerrar el modal en un envío exitoso" time="0.032">
    </testcase>
    <testcase classname="ExecutionAssistedProcessModal Component debería mostrar un mensaje de error de la API si el dispatch falla" name="ExecutionAssistedProcessModal Component debería mostrar un mensaje de error de la API si el dispatch falla" time="0.022">
    </testcase>
  </testsuite>
  <testsuite name="CreateRecordModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.365" tests="2">
    <testcase classname="CreateRecordModal muestra error si hay campos vacíos" name="CreateRecordModal muestra error si hay campos vacíos" time="0.023">
    </testcase>
    <testcase classname="CreateRecordModal envía createPath, notifica y cierra" name="CreateRecordModal envía createPath, notifica y cierra" time="0.074">
    </testcase>
  </testsuite>
  <testsuite name="DialogModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.776" tests="1">
    <testcase classname="DialogModal renderiza título/descripcion y dispara onClose/onConfirm" name="DialogModal renderiza título/descripcion y dispara onClose/onConfirm" time="0.028">
    </testcase>
  </testsuite>
  <testsuite name="ExecutingIndexGenerationModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.372" tests="3">
    <testcase classname="ExecutingIndexGenerationModal valida campos requeridos y muestra mensaje" name="ExecutingIndexGenerationModal valida campos requeridos y muestra mensaje" time="0.025">
    </testcase>
    <testcase classname="ExecutingIndexGenerationModal envía createIndex y cierra con éxito" name="ExecutingIndexGenerationModal envía createIndex y cierra con éxito" time="0.069">
    </testcase>
    <testcase classname="ExecutingIndexGenerationModal muestra error si la acción retorna error" name="ExecutingIndexGenerationModal muestra error si la acción retorna error" time="0.018">
    </testcase>
  </testsuite>
  <testsuite name="SelectSearch" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.305" tests="3">
    <testcase classname="SelectSearch muestra label y placeholder; abre/cierra con click y filtra" name="SelectSearch muestra label y placeholder; abre/cierra con click y filtra" time="0.034">
    </testcase>
    <testcase classname="SelectSearch selecciona una opción y llama onChangeOption con (option, name)" name="SelectSearch selecciona una opción y llama onChangeOption con (option, name)" time="0.007">
    </testcase>
    <testcase classname="SelectSearch abre con Enter y permite seleccionar con Enter" name="SelectSearch abre con Enter y permite seleccionar con Enter" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="Toast" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:06" time="0.839" tests="2">
    <testcase classname="Toast muestra el mensaje y la clase según type=Error" name="Toast muestra el mensaje y la clase según type=Error" time="0.072">
    </testcase>
    <testcase classname="Toast con type distinto a Error usa el ícono &quot;checkCircle&quot; y hace auto-hide" name="Toast con type distinto a Error usa el ícono &quot;checkCircle&quot; y hace auto-hide" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="DraggableElement" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.326" tests="7">
    <testcase classname="DraggableElement renderiza el objeto desde OBJECTS" name="DraggableElement renderiza el objeto desde OBJECTS" time="0.011">
    </testcase>
    <testcase classname="DraggableElement aplica clases base y estilo con posiciones" name="DraggableElement aplica clases base y estilo con posiciones" time="0.008">
    </testcase>
    <testcase classname="DraggableElement agrega clase !z-30 cuando el elemento es FIELD o FieldType.Text" name="DraggableElement agrega clase !z-30 cuando el elemento es FIELD o FieldType.Text" time="0.007">
    </testcase>
    <testcase classname="DraggableElement aplica clase activa y muestra Icon cuando lastDraggedItemId === element.id" name="DraggableElement aplica clase activa y muestra Icon cuando lastDraggedItemId === element.id" time="0.038">
    </testcase>
    <testcase classname="DraggableElement no muestra el Icon cuando no está activo" name="DraggableElement no muestra el Icon cuando no está activo" time="0.005">
    </testcase>
    <testcase classname="DraggableElement llama a onDragStart con el evento y el elemento" name="DraggableElement llama a onDragStart con el evento y el elemento" time="0.004">
    </testcase>
    <testcase classname="DraggableElement llama a onRemoveItem cuando se hace click en el Icon" name="DraggableElement llama a onRemoveItem cuando se hace click en el Icon" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="QueryingHistoricalProcesses" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.338" tests="1">
    <testcase classname="QueryingHistoricalProcesses carga datos al montar, permite consultar y exportar" name="QueryingHistoricalProcesses carga datos al montar, permite consultar y exportar" time="0.071">
    </testcase>
  </testsuite>
  <testsuite name="RequiredFields" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.32" tests="5">
    <testcase classname="RequiredFields edita campo fijo (TextInput) y actualiza con updateField" name="RequiredFields edita campo fijo (TextInput) y actualiza con updateField" time="0.022">
    </testcase>
    <testcase classname="RequiredFields selecciona opción en un campo no fijo (SelectSearch) y actualiza inputProductStructureId" name="RequiredFields selecciona opción en un campo no fijo (SelectSearch) y actualiza inputProductStructureId" time="0.015">
    </testcase>
    <testcase classname="RequiredFields toggle del checkbox: no fijo -&gt; fijo (limpia select) y fijo -&gt; no fijo (limpia content)" name="RequiredFields toggle del checkbox: no fijo -&gt; fijo (limpia select) y fijo -&gt; no fijo (limpia content)" time="0.01">
    </testcase>
    <testcase classname="RequiredFields muestra errores cuando sendModal es true y faltan valores en campos" name="RequiredFields muestra errores cuando sendModal es true y faltan valores en campos" time="0.003">
    </testcase>
    <testcase classname="RequiredFields dispara onAddField por click y por tecla ENTER" name="RequiredFields dispara onAddField por click y por tecla ENTER" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="Login page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.337" tests="5">
    <testcase classname="Login page renderiza campos y botones" name="Login page renderiza campos y botones" time="0.031">
    </testcase>
    <testcase classname="Login page envía login con credenciales válidas" name="Login page envía login con credenciales válidas" time="0.022">
    </testcase>
    <testcase classname="Login page no envía login si faltan datos" name="Login page no envía login si faltan datos" time="0.009">
    </testcase>
    <testcase classname="Login page muestra error de redux" name="Login page muestra error de redux" time="0.004">
    </testcase>
    <testcase classname="Login page Cancelar llama window.close" name="Login page Cancelar llama window.close" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="Editor" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.328" tests="6">
    <testcase classname="Editor monta (getAllProducts) y limpia en unmount (setElement, setSelectedElementType)" name="Editor monta (getAllProducts) y limpia en unmount (setElement, setSelectedElementType)" time="0.013">
    </testcase>
    <testcase classname="Editor seleccionar producto y editar campos nombre/código" name="Editor seleccionar producto y editar campos nombre/código" time="0.011">
    </testcase>
    <testcase classname="Editor crear objeto (no modify) con type=Text elimina width/height y dispara toasts" name="Editor crear objeto (no modify) con type=Text elimina width/height y dispara toasts" time="0.008">
    </testcase>
    <testcase classname="Editor modo modify: si backend responde con error formateado, muestra Toast error y no cierra" name="Editor modo modify: si backend responde con error formateado, muestra Toast error y no cierra" time="0.014">
    </testcase>
    <testcase classname="Editor Sidebar visible cuando !isModify y SidebarTools oculto si selectedElementType=Table" name="Editor Sidebar visible cuando !isModify y SidebarTools oculto si selectedElementType=Table" time="0.008">
    </testcase>
    <testcase classname="Editor requiredFields vacíos → no crea y mantiene editor" name="Editor requiredFields vacíos → no crea y mantiene editor" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="CreateRecordModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.329" tests="3">
    <testcase classname="CreateRecordModal muestra validación cuando faltan campos" name="CreateRecordModal muestra validación cuando faltan campos" time="0.024">
    </testcase>
    <testcase classname="CreateRecordModal envía y cierra cuando createInput retorna data" name="CreateRecordModal envía y cierra cuando createInput retorna data" time="0.036">
    </testcase>
    <testcase classname="CreateRecordModal muestra mensaje de error de backend si payload.data es null" name="CreateRecordModal muestra mensaje de error de backend si payload.data es null" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="Paginator (rápido y sincrónico)" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.299" tests="1">
    <testcase classname="Paginator (rápido y sincrónico) navega con flechas y crea el rango con puntos/first/last" name="Paginator (rápido y sincrónico) navega con flechas y crea el rango con puntos/first/last" time="0.041">
    </testcase>
  </testsuite>
  <testsuite name="PDF Table Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.343" tests="5">
    <testcase classname="PDF Table Component debería renderizar correctamente los encabezados y las celdas" name="PDF Table Component debería renderizar correctamente los encabezados y las celdas" time="0.022">
    </testcase>
    <testcase classname="PDF Table Component debería aplicar correctamente los atributos colSpan, rowSpan y styles" name="PDF Table Component debería aplicar correctamente los atributos colSpan, rowSpan y styles" time="0.032">
    </testcase>
    <testcase classname="PDF Table Component debería renderizar sin errores si el header o el body no están definidos" name="PDF Table Component debería renderizar sin errores si el header o el body no están definidos" time="0.004">
    </testcase>
    <testcase classname="PDF Table Component debería renderizar un tbody vacío si el array de celdas del body está vacío" name="PDF Table Component debería renderizar un tbody vacío si el array de celdas del body está vacío" time="0.012">
    </testcase>
    <testcase classname="PDF Table Component debería renderizar una tabla dispersa (sparse) correctamente" name="PDF Table Component debería renderizar una tabla dispersa (sparse) correctamente" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="AuditConsultation page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.317" tests="3">
    <testcase classname="AuditConsultation page carga datos al montar y muestra la tabla" name="AuditConsultation page carga datos al montar y muestra la tabla" time="0.028">
    </testcase>
    <testcase classname="AuditConsultation page permite exportar PDF y CSV" name="AuditConsultation page permite exportar PDF y CSV" time="0.027">
    </testcase>
    <testcase classname="AuditConsultation page permite buscar y llama displaySearchMessage" name="AuditConsultation page permite buscar y llama displaySearchMessage" time="0.015">
    </testcase>
  </testsuite>
  <testsuite name="CreateProductModal" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.319" tests="3">
    <testcase classname="CreateProductModal muestra validación cuando faltan campos" name="CreateProductModal muestra validación cuando faltan campos" time="0.019">
    </testcase>
    <testcase classname="CreateProductModal envía y cierra cuando createInput retorna data" name="CreateProductModal envía y cierra cuando createInput retorna data" time="0.013">
    </testcase>
    <testcase classname="CreateProductModal muestra mensaje de error de backend si payload es un error" name="CreateProductModal muestra mensaje de error de backend si payload es un error" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="ExitPaths page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.29" tests="1">
    <testcase classname="ExitPaths page carga productos/paths al montar; busca y abre modal" name="ExitPaths page carga productos/paths al montar; busca y abre modal" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="Icon" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.316" tests="3">
    <testcase classname="Icon muestra placeholder mientras carga y luego &lt;img&gt; con src" name="Icon muestra placeholder mientras carga y luego &lt;img&gt; con src" time="0.02">
    </testcase>
    <testcase classname="Icon no cambia el src si hoverIcon === name (maneja over/leave sin swap)" name="Icon no cambia el src si hoverIcon === name (maneja over/leave sin swap)" time="0.011">
    </testcase>
    <testcase classname="Icon ejecuta onKeyDown al presionar Enter" name="Icon ejecuta onKeyDown al presionar Enter" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="TextInput" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.298" tests="4">
    <testcase classname="TextInput Muestra correctamente label y placeholder" name="TextInput Muestra correctamente label y placeholder" time="0.012">
    </testcase>
    <testcase classname="TextInput Campo Editable" name="TextInput Campo Editable" time="0.009">
    </testcase>
    <testcase classname="TextInput Campo no Editable" name="TextInput Campo no Editable" time="0.005">
    </testcase>
    <testcase classname="TextInput llama al handleChange cuando se escribe en el campo" name="TextInput llama al handleChange cuando se escribe en el campo" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="Breadcrumb" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:07" time="0.323" tests="2">
    <testcase classname="Breadcrumb muestra los items con sus enlaces y separadores" name="Breadcrumb muestra los items con sus enlaces y separadores" time="0.028">
    </testcase>
    <testcase classname="Breadcrumb acepta className adicional" name="Breadcrumb acepta className adicional" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="Button" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.276" tests="5">
    <testcase classname="Button renderiza el texto y dispara onClick para rol NO Reading" name="Button renderiza el texto y dispara onClick para rol NO Reading" time="0.02">
    </testcase>
    <testcase classname="Button si isIcon=true renderiza el ícono plusWhite y ajusta el width del texto" name="Button si isIcon=true renderiza el ícono plusWhite y ajusta el width del texto" time="0.003">
    </testcase>
    <testcase classname="Button rol Reading + isIcon=true → NO ejecuta onClick" name="Button rol Reading + isIcon=true → NO ejecuta onClick" time="0.004">
    </testcase>
    <testcase classname="Button cuando disabled agrega clase de pointer-events-none (estilo bloqueado)" name="Button cuando disabled agrega clase de pointer-events-none (estilo bloqueado)" time="0.004">
    </testcase>
    <testcase classname="Button color=primary aplica clase de fondo azul claro" name="Button color=primary aplica clase de fondo azul claro" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="PathsDataFiles page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.293" tests="1">
    <testcase classname="PathsDataFiles page monta, busca, pagina y abre modal" name="PathsDataFiles page monta, busca, pagina y abre modal" time="0.026">
    </testcase>
  </testsuite>
  <testsuite name="NotFound page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.285" tests="2">
    <testcase classname="NotFound page muestra detalle cuando es RouteErrorResponse" name="NotFound page muestra detalle cuando es RouteErrorResponse" time="0.011">
    </testcase>
    <testcase classname="NotFound page muestra fallback &quot;Oops&quot; cuando NO es RouteErrorResponse" name="NotFound page muestra fallback &quot;Oops&quot; cuando NO es RouteErrorResponse" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Text Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.279" tests="5">
    <testcase classname="Text Component debe renderizar un &lt;p&gt; en modo PDF" name="Text Component debe renderizar un &lt;p&gt; en modo PDF" time="0.011">
    </testcase>
    <testcase classname="Text Component debe renderizar un &lt;textarea&gt; en modo normal" name="Text Component debe renderizar un &lt;textarea&gt; en modo normal" time="0.003">
    </testcase>
    <testcase classname="Text Component debe aplicar clases de preview cuando isPreviewMode es true" name="Text Component debe aplicar clases de preview cuando isPreviewMode es true" time="0.002">
    </testcase>
    <testcase classname="Text Component debe llamar a updateElementProperties al cambiar el contenido" name="Text Component debe llamar a updateElementProperties al cambiar el contenido" time="0.003">
    </testcase>
    <testcase classname="Text Component debe llamar a setElement al montar" name="Text Component debe llamar a setElement al montar" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="useModal Hook" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.264" tests="4">
    <testcase classname="useModal Hook should have a null activeModal initially" name="useModal Hook should have a null activeModal initially" time="0.007">
    </testcase>
    <testcase classname="useModal Hook should set the activeModal to a specific string when activateModal is called" name="useModal Hook should set the activeModal to a specific string when activateModal is called" time="0.002">
    </testcase>
    <testcase classname="useModal Hook should set activeModal to null when closeModal is called" name="useModal Hook should set activeModal to null when closeModal is called" time="0.002">
    </testcase>
    <testcase classname="useModal Hook should set activeModal to null when activateModal is called with null" name="useModal Hook should set activeModal to null when activateModal is called with null" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="ExecutionAssistedProcess page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.289" tests="1">
    <testcase classname="ExecutionAssistedProcess page despacha al montar, busca y abre modal" name="ExecutionAssistedProcess page despacha al montar, busca y abre modal" time="0.027">
    </testcase>
  </testsuite>
  <testsuite name="ExecutingIndexGeneration page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.301" tests="1">
    <testcase classname="ExecutingIndexGeneration page despacha getIndex al montar, busca y paginación via Table" name="ExecutingIndexGeneration page despacha getIndex al montar, busca y paginación via Table" time="0.037">
    </testcase>
  </testsuite>
  <testsuite name="useTableSelection hook" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.274" tests="5">
    <testcase classname="useTableSelection hook debería retornar un array vacío si la fila de inicio y fin son diferentes" name="useTableSelection hook debería retornar un array vacío si la fila de inicio y fin son diferentes" time="0.008">
    </testcase>
    <testcase classname="useTableSelection hook debería seleccionar correctamente las columnas del header cuando row es -1" name="useTableSelection hook debería seleccionar correctamente las columnas del header cuando row es -1" time="0.002">
    </testcase>
    <testcase classname="useTableSelection hook debería seleccionar correctamente las celdas del body" name="useTableSelection hook debería seleccionar correctamente las celdas del body" time="0.001">
    </testcase>
    <testcase classname="useTableSelection hook debería funcionar correctamente si el inicio de la selección es mayor que el fin" name="useTableSelection hook debería funcionar correctamente si el inicio de la selección es mayor que el fin" time="0.001">
    </testcase>
    <testcase classname="useTableSelection hook debería manejar el caso de no tener header o body definidos" name="useTableSelection hook debería manejar el caso de no tener header o body definidos" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="App" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.297" tests="2">
    <testcase classname="App Validar renderizado con token" name="App Validar renderizado con token" time="0.012">
    </testcase>
    <testcase classname="App Validar renderizado sin token" name="App Validar renderizado sin token" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="useDragAndDrop hook" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.279" tests="8">
    <testcase classname="useDragAndDrop hook debería tener un estado inicial vacío" name="useDragAndDrop hook debería tener un estado inicial vacío" time="0.011">
    </testcase>
    <testcase classname="useDragAndDrop hook debería llamar a calculateOffset en onDragStart" name="useDragAndDrop hook debería llamar a calculateOffset en onDragStart" time="0.001">
    </testcase>
    <testcase classname="useDragAndDrop hook debería actualizar droppedItems en onDrop" name="useDragAndDrop hook debería actualizar droppedItems en onDrop" time="0.002">
    </testcase>
    <testcase classname="useDragAndDrop hook no debería hacer nada en onDrop si no hay un item siendo arrastrado" name="useDragAndDrop hook no debería hacer nada en onDrop si no hay un item siendo arrastrado" time="0.002">
    </testcase>
    <testcase classname="useDragAndDrop hook debería limpiar las referencias en onDragEnd" name="useDragAndDrop hook debería limpiar las referencias en onDragEnd" time="0.001">
    </testcase>
    <testcase classname="useDragAndDrop hook debería remover un item con onRemoveItem" name="useDragAndDrop hook debería remover un item con onRemoveItem" time="0.002">
    </testcase>
    <testcase classname="useDragAndDrop hook debería limpiar todos los items de una página con clearPageItems" name="useDragAndDrop hook debería limpiar todos los items de una página con clearPageItems" time="0.001">
    </testcase>
    <testcase classname="useDragAndDrop hook debería resetear todo el estado con reset" name="useDragAndDrop hook debería resetear todo el estado con reset" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="Title" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.262" tests="2">
    <testcase classname="Title renderiza el título recibido por props" name="Title renderiza el título recibido por props" time="0.011">
    </testcase>
    <testcase classname="Title agrega className adicional" name="Title agrega className adicional" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="Header Component" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.286" tests="4">
    <testcase classname="Header Component debe renderizar solo los th con value" name="Header Component debe renderizar solo los th con value" time="0.026">
    </testcase>
    <testcase classname="Header Component debe renderizar Icon cuando se pasa icon" name="Header Component debe renderizar Icon cuando se pasa icon" time="0.003">
    </testcase>
    <testcase classname="Header Component debe aplicar className personalizado" name="Header Component debe aplicar className personalizado" time="0.002">
    </testcase>
    <testcase classname="Header Component cada th debe tener clases por defecto" name="Header Component cada th debe tener clases por defecto" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="InputFileUpload page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.269" tests="1">
    <testcase classname="InputFileUpload page monta, consulta, busca, pagina y abre modal" name="InputFileUpload page monta, consulta, busca, pagina y abre modal" time="0.022">
    </testcase>
  </testsuite>
  <testsuite name="About page" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.26" tests="1">
    <testcase classname="About page renderiza título y descripción" name="About page renderiza título y descripción" time="0.017">
    </testcase>
  </testsuite>
  <testsuite name="useOutsideClick" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.266" tests="3">
    <testcase classname="useOutsideClick no dispara cuando clickeo dentro" name="useOutsideClick no dispara cuando clickeo dentro" time="0.011">
    </testcase>
    <testcase classname="useOutsideClick dispara cuando clickeo fuera" name="useOutsideClick dispara cuando clickeo fuera" time="0.003">
    </testcase>
    <testcase classname="useOutsideClick deja de escuchar al hacer unmount" name="useOutsideClick deja de escuchar al hacer unmount" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="TableIcons" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.275" tests="2">
    <testcase classname="TableIcons muestra icono si status es ACTIVE y confirma cancelación" name="TableIcons muestra icono si status es ACTIVE y confirma cancelación" time="0.02">
    </testcase>
    <testcase classname="TableIcons no muestra icono si status no es ACTIVE" name="TableIcons no muestra icono si status no es ACTIVE" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="objectManageFormatSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.224" tests="5">
    <testcase classname="objectManageFormatSlice estado inicial" name="objectManageFormatSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="objectManageFormatSlice resetElement reducer → element = {}" name="objectManageFormatSlice resetElement reducer → element = {}" time="0.001">
    </testcase>
    <testcase classname="objectManageFormatSlice getObjectManageFormat.fulfilled → set data y elements" name="objectManageFormatSlice getObjectManageFormat.fulfilled → set data y elements" time="0">
    </testcase>
    <testcase classname="objectManageFormatSlice getOneObject.fulfilled → set element" name="objectManageFormatSlice getOneObject.fulfilled → set element" time="0.001">
    </testcase>
    <testcase classname="objectManageFormatSlice deleteObject.fulfilled → set elements y message" name="objectManageFormatSlice deleteObject.fulfilled → set elements y message" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="useTableData hook" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.268" tests="4">
    <testcase classname="useTableData hook debería inicializar el estado con los datos proporcionados" name="useTableData hook debería inicializar el estado con los datos proporcionados" time="0.01">
    </testcase>
    <testcase classname="useTableData hook debería actualizar un campo específico con onFieldChange" name="useTableData hook debería actualizar un campo específico con onFieldChange" time="0.001">
    </testcase>
    <testcase classname="useTableData hook debería reemplazar completamente los datos con updateData" name="useTableData hook debería reemplazar completamente los datos con updateData" time="0.002">
    </testcase>
    <testcase classname="useTableData hook debería fusionar los datos cuando los datos de entrada (allData) cambian, preservando ediciones locales" name="useTableData hook debería fusionar los datos cuando los datos de entrada (allData) cambian, preservando ediciones locales" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="Fetch utility" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.223" tests="6">
    <testcase classname="Fetch utility debería realizar una petición fetch sin el token de autorización si no existe" name="Fetch utility debería realizar una petición fetch sin el token de autorización si no existe" time="0.003">
    </testcase>
    <testcase classname="Fetch utility debería añadir el token de autorización a los headers si existe" name="Fetch utility debería añadir el token de autorización a los headers si existe" time="0">
    </testcase>
    <testcase classname="Fetch utility debería lanzar un error si la respuesta de la petición no es &quot;ok&quot;" name="Fetch utility debería lanzar un error si la respuesta de la petición no es &quot;ok&quot;" time="0.008">
    </testcase>
    <testcase classname="Fetch utility debería limpiar localStorage si el error es UNAUTHORIZED (401)" name="Fetch utility debería limpiar localStorage si el error es UNAUTHORIZED (401)" time="0.002">
    </testcase>
    <testcase classname="Fetch utility debería limpiar localStorage si el error es FORBIDDEN (403)" name="Fetch utility debería limpiar localStorage si el error es FORBIDDEN (403)" time="0.001">
    </testcase>
    <testcase classname="Fetch utility no debería limpiar localStorage para otros errores de red" name="Fetch utility no debería limpiar localStorage para otros errores de red" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="executingIndexGenerationSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.225" tests="4">
    <testcase classname="executingIndexGenerationSlice estado inicial" name="executingIndexGenerationSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="executingIndexGenerationSlice createIndex.fulfilled → set elements" name="executingIndexGenerationSlice createIndex.fulfilled → set elements" time="0.001">
    </testcase>
    <testcase classname="executingIndexGenerationSlice getIndex.fulfilled → set data y elements desde content" name="executingIndexGenerationSlice getIndex.fulfilled → set data y elements desde content" time="0">
    </testcase>
    <testcase classname="executingIndexGenerationSlice getIndex.fulfilled con content ausente → elements=[]" name="executingIndexGenerationSlice getIndex.fulfilled con content ausente → elements=[]" time="0">
    </testcase>
  </testsuite>
  <testsuite name="exit-paths thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.215" tests="4">
    <testcase classname="exit-paths thunks getExitPaths fulfilled" name="exit-paths thunks getExitPaths fulfilled" time="0.004">
    </testcase>
    <testcase classname="exit-paths thunks createPath agrega con addItem y retorna message" name="exit-paths thunks createPath agrega con addItem y retorna message" time="0.001">
    </testcase>
    <testcase classname="exit-paths thunks deletePath filtra con deleteItem y retorna message" name="exit-paths thunks deletePath filtra con deleteItem y retorna message" time="0">
    </testcase>
    <testcase classname="exit-paths thunks updatePath reemplaza con replaceItem" name="exit-paths thunks updatePath reemplaza con replaceItem" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="executionAssistedProcessSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.22" tests="3">
    <testcase classname="executionAssistedProcessSlice estado inicial" name="executionAssistedProcessSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="executionAssistedProcessSlice getAssistedProcess.fulfilled → set data y elements desde content" name="executionAssistedProcessSlice getAssistedProcess.fulfilled → set data y elements desde content" time="0">
    </testcase>
    <testcase classname="executionAssistedProcessSlice getAssistedProcess.fulfilled sin content → elements=[]" name="executionAssistedProcessSlice getAssistedProcess.fulfilled sin content → elements=[]" time="0">
    </testcase>
  </testsuite>
  <testsuite name="execution-assisted-process thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.229" tests="3">
    <testcase classname="execution-assisted-process thunks createAssistedProcess retorna data y mensaje" name="execution-assisted-process thunks createAssistedProcess retorna data y mensaje" time="0.003">
    </testcase>
    <testcase classname="execution-assisted-process thunks getAssistedProcess retorna data del api" name="execution-assisted-process thunks getAssistedProcess retorna data del api" time="0">
    </testcase>
    <testcase classname="execution-assisted-process thunks createAssistedProcess rejected en error" name="execution-assisted-process thunks createAssistedProcess rejected en error" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="pdf thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.224" tests="7">
    <testcase classname="pdf thunks activateFormat retorna message y despacha un thunk (getFormats) cuando data existe" name="pdf thunks activateFormat retorna message y despacha un thunk (getFormats) cuando data existe" time="0.002">
    </testcase>
    <testcase classname="pdf thunks createFormat fulfilled" name="pdf thunks createFormat fulfilled" time="0.001">
    </testcase>
    <testcase classname="pdf thunks createFormat rejected mapea error" name="pdf thunks createFormat rejected mapea error" time="0.002">
    </testcase>
    <testcase classname="pdf thunks getFormats fulfilled" name="pdf thunks getFormats fulfilled" time="0.001">
    </testcase>
    <testcase classname="pdf thunks getProductObjects fulfilled" name="pdf thunks getProductObjects fulfilled" time="0.001">
    </testcase>
    <testcase classname="pdf thunks updateFormat fulfilled" name="pdf thunks updateFormat fulfilled" time="0.004">
    </testcase>
    <testcase classname="pdf thunks updateFormat rejected" name="pdf thunks updateFormat rejected" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="manageContentProductSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.225" tests="5">
    <testcase classname="manageContentProductSlice estado inicial" name="manageContentProductSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="manageContentProductSlice getManageContentProduct.fulfilled → set manageData y content" name="manageContentProductSlice getManageContentProduct.fulfilled → set manageData y content" time="0.001">
    </testcase>
    <testcase classname="manageContentProductSlice createManageContentProduct.fulfilled → reemplaza content" name="manageContentProductSlice createManageContentProduct.fulfilled → reemplaza content" time="0">
    </testcase>
    <testcase classname="manageContentProductSlice modifyManageContentProduct.fulfilled → reemplaza content" name="manageContentProductSlice modifyManageContentProduct.fulfilled → reemplaza content" time="0.001">
    </testcase>
    <testcase classname="manageContentProductSlice deleteContentProduct.fulfilled → usa payload.data como content" name="manageContentProductSlice deleteContentProduct.fulfilled → usa payload.data como content" time="0">
    </testcase>
  </testsuite>
  <testsuite name="pdfSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.214" tests="4">
    <testcase classname="pdfSlice estado inicial" name="pdfSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="pdfSlice getFormats.fulfilled → guarda formats y pages" name="pdfSlice getFormats.fulfilled → guarda formats y pages" time="0.001">
    </testcase>
    <testcase classname="pdfSlice getProductObjects.fulfilled → guarda objects" name="pdfSlice getProductObjects.fulfilled → guarda objects" time="0">
    </testcase>
    <testcase classname="pdfSlice resetObjects → limpia objects" name="pdfSlice resetObjects → limpia objects" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="auth/actions -&gt; login thunk" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.214" tests="3">
    <testcase classname="auth/actions -&gt; login thunk resuelve &quot;fulfilled&quot;, llama a fetchClient.post y guarda el token en caso de éxito" name="auth/actions -&gt; login thunk resuelve &quot;fulfilled&quot;, llama a fetchClient.post y guarda el token en caso de éxito" time="0.003">
    </testcase>
    <testcase classname="auth/actions -&gt; login thunk resuelve &quot;rejected&quot; si la respuesta de la API no contiene data.user" name="auth/actions -&gt; login thunk resuelve &quot;rejected&quot; si la respuesta de la API no contiene data.user" time="0.001">
    </testcase>
    <testcase classname="auth/actions -&gt; login thunk resuelve &quot;rejected&quot; si fetchClient.post lanza un error de red" name="auth/actions -&gt; login thunk resuelve &quot;rejected&quot; si fetchClient.post lanza un error de red" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="paths-data-files thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.204" tests="3">
    <testcase classname="paths-data-files thunks getPathsDataFile mapea product.id" name="paths-data-files thunks getPathsDataFile mapea product.id" time="0.003">
    </testcase>
    <testcase classname="paths-data-files thunks createPathDataFile coloca nuevo al inicio y desactiva similares activos del mismo producto" name="paths-data-files thunks createPathDataFile coloca nuevo al inicio y desactiva similares activos del mismo producto" time="0.001">
    </testcase>
    <testcase classname="paths-data-files thunks modifyPathDataFile actualiza y aplica regla de similitud" name="paths-data-files thunks modifyPathDataFile actualiza y aplica regla de similitud" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="urls builders" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.201" tests="15">
    <testcase classname="urls builders auth" name="urls builders auth" time="0.001">
    </testcase>
    <testcase classname="urls builders exitPaths" name="urls builders exitPaths" time="0.001">
    </testcase>
    <testcase classname="urls builders pathsDataFiles" name="urls builders pathsDataFiles" time="0.001">
    </testcase>
    <testcase classname="urls builders pdf" name="urls builders pdf" time="0">
    </testcase>
    <testcase classname="urls builders productInput" name="urls builders productInput" time="0.001">
    </testcase>
    <testcase classname="urls builders productManagement" name="urls builders productManagement" time="0">
    </testcase>
    <testcase classname="urls builders userManagement" name="urls builders userManagement" time="0.001">
    </testcase>
    <testcase classname="urls builders userRoles" name="urls builders userRoles" time="0">
    </testcase>
    <testcase classname="urls builders manageContentProduct" name="urls builders manageContentProduct" time="0">
    </testcase>
    <testcase classname="urls builders objectManageFormat" name="urls builders objectManageFormat" time="0.001">
    </testcase>
    <testcase classname="urls builders executingIndexGeneration" name="urls builders executingIndexGeneration" time="0">
    </testcase>
    <testcase classname="urls builders inputFileUpload" name="urls builders inputFileUpload" time="0">
    </testcase>
    <testcase classname="urls builders auditConsultation" name="urls builders auditConsultation" time="0.001">
    </testcase>
    <testcase classname="urls builders executingAssistedProcess" name="urls builders executingAssistedProcess" time="0">
    </testcase>
    <testcase classname="urls builders queryingHistoricalProcesses" name="urls builders queryingHistoricalProcesses" time="0">
    </testcase>
  </testsuite>
  <testsuite name="object-manage-format thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.201" tests="6">
    <testcase classname="object-manage-format thunks getObjectManageFormat mapea elementos" name="object-manage-format thunks getObjectManageFormat mapea elementos" time="0.002">
    </testcase>
    <testcase classname="object-manage-format thunks getOneObject devuelve data" name="object-manage-format thunks getOneObject devuelve data" time="0">
    </testcase>
    <testcase classname="object-manage-format thunks createObjectManageFormat devuelve {data, message}" name="object-manage-format thunks createObjectManageFormat devuelve {data, message}" time="0">
    </testcase>
    <testcase classname="object-manage-format thunks deleteObject filtra y devuelve message" name="object-manage-format thunks deleteObject filtra y devuelve message" time="0.001">
    </testcase>
    <testcase classname="object-manage-format thunks deleteObject rejected retorna {data:null, message:extractErrorMessage}" name="object-manage-format thunks deleteObject rejected retorna {data:null, message:extractErrorMessage}" time="0.001">
    </testcase>
    <testcase classname="object-manage-format thunks modifyObjectManageFormat fulfilled" name="object-manage-format thunks modifyObjectManageFormat fulfilled" time="0">
    </testcase>
  </testsuite>
  <testsuite name="generateRandomString" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.193" tests="3">
    <testcase classname="generateRandomString devuelve 16 caracteres por defecto" name="generateRandomString devuelve 16 caracteres por defecto" time="0.002">
    </testcase>
    <testcase classname="generateRandomString devuelve la longitud solicitada" name="generateRandomString devuelve la longitud solicitada" time="0.001">
    </testcase>
    <testcase classname="generateRandomString cuando length=0, usa longitud aleatoria; podemos forzarla a 30" name="generateRandomString cuando length=0, usa longitud aleatoria; podemos forzarla a 30" time="0">
    </testcase>
  </testsuite>
  <testsuite name="userRolesSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.207" tests="12">
    <testcase classname="userRolesSlice estado inicial" name="userRolesSlice estado inicial" time="0.003">
    </testcase>
    <testcase classname="userRolesSlice getUserRoles.fulfilled set allData cuando payload es un array" name="userRolesSlice getUserRoles.fulfilled set allData cuando payload es un array" time="0.001">
    </testcase>
    <testcase classname="userRolesSlice getUserRoles.fulfilled set allData y pages cuando payload es un objeto con content y totalPages" name="userRolesSlice getUserRoles.fulfilled set allData y pages cuando payload es un objeto con content y totalPages" time="0">
    </testcase>
    <testcase classname="userRolesSlice getUserRoles.fulfilled si payload es objeto sin content ni totalPages, deja allData vacío y no toca pages" name="userRolesSlice getUserRoles.fulfilled si payload es objeto sin content ni totalPages, deja allData vacío y no toca pages" time="0">
    </testcase>
    <testcase classname="userRolesSlice getUserRoles.rejected usa action.payload si existe" name="userRolesSlice getUserRoles.rejected usa action.payload si existe" time="0.001">
    </testcase>
    <testcase classname="userRolesSlice getUserRoles.rejected usa action.error.message si no hay payload" name="userRolesSlice getUserRoles.rejected usa action.error.message si no hay payload" time="0">
    </testcase>
    <testcase classname="userRolesSlice getUserRoles.rejected usa fallback &quot;Error&quot; si no hay payload ni error" name="userRolesSlice getUserRoles.rejected usa fallback &quot;Error&quot; si no hay payload ni error" time="0">
    </testcase>
    <testcase classname="userRolesSlice updateRole.fulfilled reemplaza allData y setea message" name="userRolesSlice updateRole.fulfilled reemplaza allData y setea message" time="0.001">
    </testcase>
    <testcase classname="userRolesSlice updateRole.fulfilled mantiene allData si no hay data en el payload" name="userRolesSlice updateRole.fulfilled mantiene allData si no hay data en el payload" time="0">
    </testcase>
    <testcase classname="userRolesSlice updateRole.rejected usa action.payload si existe" name="userRolesSlice updateRole.rejected usa action.payload si existe" time="0.001">
    </testcase>
    <testcase classname="userRolesSlice updateRole.rejected usa action.error.message si no hay payload" name="userRolesSlice updateRole.rejected usa action.error.message si no hay payload" time="0">
    </testcase>
    <testcase classname="userRolesSlice updateRole.rejected usa fallback &quot;Error&quot; si no hay payload ni error" name="userRolesSlice updateRole.rejected usa fallback &quot;Error&quot; si no hay payload ni error" time="0">
    </testcase>
  </testsuite>
  <testsuite name="pathsSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:08" time="0.21" tests="5">
    <testcase classname="pathsSlice estado inicial" name="pathsSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="pathsSlice getExitPaths.fulfilled → set paths/pages" name="pathsSlice getExitPaths.fulfilled → set paths/pages" time="0.001">
    </testcase>
    <testcase classname="pathsSlice createPath.fulfilled → reemplaza paths por payload.data" name="pathsSlice createPath.fulfilled → reemplaza paths por payload.data" time="0">
    </testcase>
    <testcase classname="pathsSlice updatePath.fulfilled → reemplaza paths por payload.data" name="pathsSlice updatePath.fulfilled → reemplaza paths por payload.data" time="0">
    </testcase>
    <testcase classname="pathsSlice deletePath.fulfilled → reemplaza paths por payload.data" name="pathsSlice deletePath.fulfilled → reemplaza paths por payload.data" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="user-management thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.206" tests="3">
    <testcase classname="user-management thunks getUserManagement mapea userName" name="user-management thunks getUserManagement mapea userName" time="0.003">
    </testcase>
    <testcase classname="user-management thunks createUserManagement mapea userName en el data" name="user-management thunks createUserManagement mapea userName en el data" time="0">
    </testcase>
    <testcase classname="user-management thunks modifyUserManagement usa replaceItem con users del state" name="user-management thunks modifyUserManagement usa replaceItem con users del state" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="createRequestParams" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.193" tests="3">
    <testcase classname="createRequestParams con defaults: page=0 y search vacío" name="createRequestParams con defaults: page=0 y search vacío" time="0.001">
    </testcase>
    <testcase classname="createRequestParams omite page si es negativo" name="createRequestParams omite page si es negativo" time="0">
    </testcase>
    <testcase classname="createRequestParams incluye search cuando se envía" name="createRequestParams incluye search cuando se envía" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="sidebar slice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.201" tests="3">
    <testcase classname="sidebar slice estado inicial isOpen = true" name="sidebar slice estado inicial isOpen = true" time="0.002">
    </testcase>
    <testcase classname="sidebar slice openSidebar -&gt; true" name="sidebar slice openSidebar -&gt; true" time="0.001">
    </testcase>
    <testcase classname="sidebar slice toggleSidebar alterna valor" name="sidebar slice toggleSidebar alterna valor" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="authSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.194" tests="3">
    <testcase classname="authSlice cleanError limpia error" name="authSlice cleanError limpia error" time="0.002">
    </testcase>
    <testcase classname="authSlice login.fulfilled setea user y token" name="authSlice login.fulfilled setea user y token" time="0.001">
    </testcase>
    <testcase classname="authSlice login.rejected mantiene o setea error (ajusta según tu slice)" name="authSlice login.rejected mantiene o setea error (ajusta según tu slice)" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="userManagementSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.206" tests="6">
    <testcase classname="userManagementSlice estado inicial" name="userManagementSlice estado inicial" time="0.001">
    </testcase>
    <testcase classname="userManagementSlice getUserManagement.fulfilled → set data/users y limpia error" name="userManagementSlice getUserManagement.fulfilled → set data/users y limpia error" time="0.001">
    </testcase>
    <testcase classname="userManagementSlice getUserManagement.rejected → set error" name="userManagementSlice getUserManagement.rejected → set error" time="0.001">
    </testcase>
    <testcase classname="userManagementSlice createUserManagement.fulfilled con lista &gt;=10 → pop y unshift" name="userManagementSlice createUserManagement.fulfilled con lista &gt;=10 → pop y unshift" time="0.005">
    </testcase>
    <testcase classname="userManagementSlice createUserManagement.rejected → set error" name="userManagementSlice createUserManagement.rejected → set error" time="0">
    </testcase>
    <testcase classname="userManagementSlice modifyUserManagement.fulfilled → reemplaza users y setea message" name="userManagementSlice modifyUserManagement.fulfilled → reemplaza users y setea message" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Data Export Utilities" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.197" tests="3">
    <testcase classname="Data Export Utilities handleExportCSV debería generar un CSV y simular su descarga" name="Data Export Utilities handleExportCSV debería generar un CSV y simular su descarga" time="0.004">
    </testcase>
    <testcase classname="Data Export Utilities handleExportPDF debería abrir una nueva ventana e invocar la impresión si encuentra una tabla" name="Data Export Utilities handleExportPDF debería abrir una nueva ventana e invocar la impresión si encuentra una tabla" time="0.004">
    </testcase>
    <testcase classname="Data Export Utilities handleExportPDF no debería hacer nada si no encuentra una tabla en el documento" name="Data Export Utilities handleExportPDF no debería hacer nada si no encuentra una tabla en el documento" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="product-input thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.214" tests="10">
    <testcase classname="product-input thunks createInput -&gt; addItem con state.productInput.inputs y retorna message" name="product-input thunks createInput -&gt; addItem con state.productInput.inputs y retorna message" time="0.002">
    </testcase>
    <testcase classname="product-input thunks createInput -&gt; rejected formateando error" name="product-input thunks createInput -&gt; rejected formateando error" time="0.002">
    </testcase>
    <testcase classname="product-input thunks deleteInput -&gt; deleteItem con (inputs, data.id) y retorna message" name="product-input thunks deleteInput -&gt; deleteItem con (inputs, data.id) y retorna message" time="0.001">
    </testcase>
    <testcase classname="product-input thunks deleteInput -&gt; rejected formateando error" name="product-input thunks deleteInput -&gt; rejected formateando error" time="0.001">
    </testcase>
    <testcase classname="product-input thunks getInputs -&gt; fulfilled devuelve data" name="product-input thunks getInputs -&gt; fulfilled devuelve data" time="0.001">
    </testcase>
    <testcase classname="product-input thunks getInputs -&gt; rejected" name="product-input thunks getInputs -&gt; rejected" time="0.001">
    </testcase>
    <testcase classname="product-input thunks updateInput -&gt; replaceItem con state.productInput.inputs y retorna message" name="product-input thunks updateInput -&gt; replaceItem con state.productInput.inputs y retorna message" time="0">
    </testcase>
    <testcase classname="product-input thunks updateInput -&gt; rejected formateando error" name="product-input thunks updateInput -&gt; rejected formateando error" time="0.001">
    </testcase>
    <testcase classname="product-input thunks getAllInputs -&gt; fulfilled" name="product-input thunks getAllInputs -&gt; fulfilled" time="0">
    </testcase>
    <testcase classname="product-input thunks getAllInputs -&gt; rejected" name="product-input thunks getAllInputs -&gt; rejected" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="input-file-upload thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.212" tests="4">
    <testcase classname="input-file-upload thunks createFile agrega (mapeando productName y userName) al inicio y limita a 10" name="input-file-upload thunks createFile agrega (mapeando productName y userName) al inicio y limita a 10" time="0.003">
    </testcase>
    <testcase classname="input-file-upload thunks getFile mapea content a productName y userName" name="input-file-upload thunks getFile mapea content a productName y userName" time="0.001">
    </testcase>
    <testcase classname="input-file-upload thunks cancelFile retorna {data, message} del api" name="input-file-upload thunks cancelFile retorna {data, message} del api" time="0.001">
    </testcase>
    <testcase classname="input-file-upload thunks createFile rejected en error" name="input-file-upload thunks createFile rejected en error" time="0.011">
    </testcase>
  </testsuite>
  <testsuite name="productManagementSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.22" tests="8">
    <testcase classname="productManagementSlice estado inicial" name="productManagementSlice estado inicial" time="0.004">
    </testcase>
    <testcase classname="productManagementSlice getProductManagement.fulfilled → set data y products" name="productManagementSlice getProductManagement.fulfilled → set data y products" time="0.001">
    </testcase>
    <testcase classname="productManagementSlice getProductManagement.rejected → set error" name="productManagementSlice getProductManagement.rejected → set error" time="0.004">
    </testcase>
    <testcase classname="productManagementSlice getAllProducts.fulfilled → set allProducts" name="productManagementSlice getAllProducts.fulfilled → set allProducts" time="0">
    </testcase>
    <testcase classname="productManagementSlice createProductManagement.fulfilled con lista &gt;=10 → hace pop y agrega primero" name="productManagementSlice createProductManagement.fulfilled con lista &gt;=10 → hace pop y agrega primero" time="0.002">
    </testcase>
    <testcase classname="productManagementSlice createProductManagement.rejected → set error" name="productManagementSlice createProductManagement.rejected → set error" time="0">
    </testcase>
    <testcase classname="productManagementSlice modifyProductManagement.fulfilled → reemplaza producto por id y setea message" name="productManagementSlice modifyProductManagement.fulfilled → reemplaza producto por id y setea message" time="0.001">
    </testcase>
    <testcase classname="productManagementSlice modifyProductManagement.rejected → set error" name="productManagementSlice modifyProductManagement.rejected → set error" time="0">
    </testcase>
  </testsuite>
  <testsuite name="validatePattern" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.202" tests="2">
    <testcase classname="validatePattern true cuando coincide" name="validatePattern true cuando coincide" time="0.001">
    </testcase>
    <testcase classname="validatePattern false cuando NO coincide" name="validatePattern false cuando NO coincide" time="0">
    </testcase>
  </testsuite>
  <testsuite name="user-roles thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.21" tests="4">
    <testcase classname="user-roles thunks getUserRoles -&gt; fulfilled" name="user-roles thunks getUserRoles -&gt; fulfilled" time="0.002">
    </testcase>
    <testcase classname="user-roles thunks getUserRoles -&gt; rejected" name="user-roles thunks getUserRoles -&gt; rejected" time="0.001">
    </testcase>
    <testcase classname="user-roles thunks updateRole -&gt; usa replaceItem con roles.allData y retorna message" name="user-roles thunks updateRole -&gt; usa replaceItem con roles.allData y retorna message" time="0.001">
    </testcase>
    <testcase classname="user-roles thunks updateRole -&gt; rejected retorna {data:error, message:String(error)}" name="user-roles thunks updateRole -&gt; rejected retorna {data:error, message:String(error)}" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="executing-index-generation thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.225" tests="3">
    <testcase classname="executing-index-generation thunks createIndex agrega al inicio y limita a 10" name="executing-index-generation thunks createIndex agrega al inicio y limita a 10" time="0.003">
    </testcase>
    <testcase classname="executing-index-generation thunks getIndex retorna data del api" name="executing-index-generation thunks getIndex retorna data del api" time="0.001">
    </testcase>
    <testcase classname="executing-index-generation thunks createIndex rejected en error" name="executing-index-generation thunks createIndex rejected en error" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="object utils" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.2" tests="7">
    <testcase classname="object utils hasEmptyFields true si alguna key está vacía (string vacío, 0/false no se consideran vacíos aquí a menos que así lo definas)" name="object utils hasEmptyFields true si alguna key está vacía (string vacío, 0/false no se consideran vacíos aquí a menos que así lo definas)" time="0.001">
    </testcase>
    <testcase classname="object utils hasEmptyFields false si todas las keys tienen valor (no vacío)" name="object utils hasEmptyFields false si todas las keys tienen valor (no vacío)" time="0.001">
    </testcase>
    <testcase classname="object utils hasEmptyFields usa la lista de fields si se envía" name="object utils hasEmptyFields usa la lista de fields si se envía" time="0">
    </testcase>
    <testcase classname="object utils removeEmptyStrings elimina solo propiedades con string vacío" name="object utils removeEmptyStrings elimina solo propiedades con string vacío" time="0.001">
    </testcase>
    <testcase classname="object utils isEmptyObject true si no hay keys" name="object utils isEmptyObject true si no hay keys" time="0">
    </testcase>
    <testcase classname="object utils isEmptyObject false si hay al menos una key" name="object utils isEmptyObject false si hay al menos una key" time="0">
    </testcase>
    <testcase classname="object utils removeProperties retorna un clon sin las keys indicadas y no muta el source" name="object utils removeProperties retorna un clon sin las keys indicadas y no muta el source" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="getBaseUrl" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.187" tests="2">
    <testcase classname="getBaseUrl retorna process.env.VITE_BASE_URL si existe" name="getBaseUrl retorna process.env.VITE_BASE_URL si existe" time="0.002">
    </testcase>
    <testcase classname="getBaseUrl retorna &quot;&quot; si no hay process.env ni Vite import.meta" name="getBaseUrl retorna &quot;&quot; si no hay process.env ni Vite import.meta" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="product-management thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.217" tests="5">
    <testcase classname="product-management thunks getProductManagement -&gt; fulfilled" name="product-management thunks getProductManagement -&gt; fulfilled" time="0.003">
    </testcase>
    <testcase classname="product-management thunks getProductManagement -&gt; rejected" name="product-management thunks getProductManagement -&gt; rejected" time="0.001">
    </testcase>
    <testcase classname="product-management thunks getAllProducts -&gt; mapea {label, value}" name="product-management thunks getAllProducts -&gt; mapea {label, value}" time="0.001">
    </testcase>
    <testcase classname="product-management thunks createProductManagement -&gt; fulfilled" name="product-management thunks createProductManagement -&gt; fulfilled" time="0">
    </testcase>
    <testcase classname="product-management thunks modifyProductManagement -&gt; fulfilled" name="product-management thunks modifyProductManagement -&gt; fulfilled" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="extractErrorMessage" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.196" tests="3">
    <testcase classname="extractErrorMessage extrae el primer mensaje del array" name="extractErrorMessage extrae el primer mensaje del array" time="0.001">
    </testcase>
    <testcase classname="extractErrorMessage retorna &quot;&quot; cuando el array viene vacío" name="extractErrorMessage retorna &quot;&quot; cuando el array viene vacío" time="0.001">
    </testcase>
    <testcase classname="extractErrorMessage retorna &quot;&quot; cuando no existe &quot;message&quot; en el objeto" name="extractErrorMessage retorna &quot;&quot; cuando no existe &quot;message&quot; en el objeto" time="0">
    </testcase>
  </testsuite>
  <testsuite name="utils: getDiff" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.196" tests="4">
    <testcase classname="utils: getDiff devuelve sólo props cambiadas" name="utils: getDiff devuelve sólo props cambiadas" time="0.004">
    </testcase>
    <testcase classname="utils: getDiff ignora keys con ignoreKeys" name="utils: getDiff ignora keys con ignoreKeys" time="0.001">
    </testcase>
    <testcase classname="utils: getDiff usa customComparators por key" name="utils: getDiff usa customComparators por key" time="0">
    </testcase>
    <testcase classname="utils: getDiff si falta original o modified, retorna {}" name="utils: getDiff si falta original o modified, retorna {}" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="productInputSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.237" tests="6">
    <testcase classname="productInputSlice getInputs.fulfilled → setea inputs y pages" name="productInputSlice getInputs.fulfilled → setea inputs y pages" time="0.003">
    </testcase>
    <testcase classname="productInputSlice createInput.fulfilled → reemplaza inputs por payload.data" name="productInputSlice createInput.fulfilled → reemplaza inputs por payload.data" time="0">
    </testcase>
    <testcase classname="productInputSlice deleteInput.fulfilled → reemplaza inputs por payload.data" name="productInputSlice deleteInput.fulfilled → reemplaza inputs por payload.data" time="0.001">
    </testcase>
    <testcase classname="productInputSlice updateInput.fulfilled → reemplaza inputs por payload.data" name="productInputSlice updateInput.fulfilled → reemplaza inputs por payload.data" time="0">
    </testcase>
    <testcase classname="productInputSlice getAllInputs.fulfilled → setea allInputs" name="productInputSlice getAllInputs.fulfilled → setea allInputs" time="0.001">
    </testcase>
    <testcase classname="productInputSlice resetAllInputs reducer → limpia allInputs" name="productInputSlice resetAllInputs reducer → limpia allInputs" time="0">
    </testcase>
  </testsuite>
  <testsuite name="manage-content-product thunks" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.218" tests="5">
    <testcase classname="manage-content-product thunks getManageContentProduct mapea content (product -&gt; id, mappedRequiredFields)" name="manage-content-product thunks getManageContentProduct mapea content (product -&gt; id, mappedRequiredFields)" time="0.002">
    </testcase>
    <testcase classname="manage-content-product thunks createManageContentProduct agrega el nuevo al inicio y hace slice del resto" name="manage-content-product thunks createManageContentProduct agrega el nuevo al inicio y hace slice del resto" time="0.001">
    </testcase>
    <testcase classname="manage-content-product thunks modifyManageContentProduct reemplaza el item por id y mapea" name="manage-content-product thunks modifyManageContentProduct reemplaza el item por id y mapea" time="0.001">
    </testcase>
    <testcase classname="manage-content-product thunks deleteContentProduct retorna lista filtrada y message del API" name="manage-content-product thunks deleteContentProduct retorna lista filtrada y message del API" time="0.001">
    </testcase>
    <testcase classname="manage-content-product thunks getManageContentProduct rejected on error" name="manage-content-product thunks getManageContentProduct rejected on error" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="inputFileUploadSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.233" tests="3">
    <testcase classname="inputFileUploadSlice estado inicial" name="inputFileUploadSlice estado inicial" time="0.002">
    </testcase>
    <testcase classname="inputFileUploadSlice createFile.fulfilled → set elements" name="inputFileUploadSlice createFile.fulfilled → set elements" time="0">
    </testcase>
    <testcase classname="inputFileUploadSlice getFile.fulfilled → set data y elements (content)" name="inputFileUploadSlice getFile.fulfilled → set data y elements (content)" time="0">
    </testcase>
  </testsuite>
  <testsuite name="DragAndDrop Utilities" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.217" tests="6">
    <testcase classname="DragAndDrop Utilities calculateOffset should correctly calculate and update the drag offset and drag item refs" name="DragAndDrop Utilities calculateOffset should correctly calculate and update the drag offset and drag item refs" time="0.003">
    </testcase>
    <testcase classname="DragAndDrop Utilities computeDropPosition should compute the correct position when dropped inside boundaries" name="DragAndDrop Utilities computeDropPosition should compute the correct position when dropped inside boundaries" time="0.001">
    </testcase>
    <testcase classname="DragAndDrop Utilities computeDropPosition should clamp the position to the top and left boundaries if dropped too far" name="DragAndDrop Utilities computeDropPosition should clamp the position to the top and left boundaries if dropped too far" time="0.001">
    </testcase>
    <testcase classname="DragAndDrop Utilities computeDropPosition should clamp the position to the right and bottom boundaries if dropped too far" name="DragAndDrop Utilities computeDropPosition should clamp the position to the right and bottom boundaries if dropped too far" time="0">
    </testcase>
    <testcase classname="DragAndDrop Utilities addOrUpdateDroppedItem should update an existing item if its ID is already in the list" name="DragAndDrop Utilities addOrUpdateDroppedItem should update an existing item if its ID is already in the list" time="0.001">
    </testcase>
    <testcase classname="DragAndDrop Utilities addOrUpdateDroppedItem should add a new item with a unique ID if it does not exist in the list" name="DragAndDrop Utilities addOrUpdateDroppedItem should add a new item with a unique ID if it does not exist in the list" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="useTableOperations" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.221" tests="10">
    <testcase classname="useTableOperations handleAddColumn agrega una columna y celdas por cada fila" name="useTableOperations handleAddColumn agrega una columna y celdas por cada fila" time="0.002">
    </testcase>
    <testcase classname="useTableOperations handleAddRow agrega una fila con tantas columnas como header" name="useTableOperations handleAddRow agrega una fila con tantas columnas como header" time="0.001">
    </testcase>
    <testcase classname="useTableOperations handleUpdateHeaderCell actualiza label en header" name="useTableOperations handleUpdateHeaderCell actualiza label en header" time="0">
    </testcase>
    <testcase classname="useTableOperations handleUpdateBodyCell actualiza contenido en body" name="useTableOperations handleUpdateBodyCell actualiza contenido en body" time="0">
    </testcase>
    <testcase classname="useTableOperations updateSelectedCellStyle → header (row=-1) y body" name="useTableOperations updateSelectedCellStyle → header (row=-1) y body" time="0.001">
    </testcase>
    <testcase classname="useTableOperations handleMergeCells → merge header mismo row" name="useTableOperations handleMergeCells → merge header mismo row" time="0.001">
    </testcase>
    <testcase classname="useTableOperations handleMergeCells → merge body mismo row" name="useTableOperations handleMergeCells → merge body mismo row" time="0">
    </testcase>
    <testcase classname="useTableOperations handleMergeCells → split header cuando selectedCells tiene un solo item con colSpan&gt;1" name="useTableOperations handleMergeCells → split header cuando selectedCells tiene un solo item con colSpan&gt;1" time="0.001">
    </testcase>
    <testcase classname="useTableOperations handleMergeCells → split body cuando un item tiene colSpan&gt;1" name="useTableOperations handleMergeCells → split body cuando un item tiene colSpan&gt;1" time="0">
    </testcase>
    <testcase classname="useTableOperations handleMergeCells → returns si vacío, o si no es mismo row" name="useTableOperations handleMergeCells → returns si vacío, o si no es mismo row" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="pdf margins utils" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.207" tests="3">
    <testcase classname="pdf margins utils cmToPx convierte correctamente" name="pdf margins utils cmToPx convierte correctamente" time="0.002">
    </testcase>
    <testcase classname="pdf margins utils getCssMarginVars devuelve variables CSS con px" name="pdf margins utils getCssMarginVars devuelve variables CSS con px" time="0.001">
    </testcase>
    <testcase classname="pdf margins utils convertMarginsToPx convierte cada lado" name="pdf margins utils convertMarginsToPx convierte cada lado" time="0">
    </testcase>
  </testsuite>
  <testsuite name="pathsDataFileSlice" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.227" tests="4">
    <testcase classname="pathsDataFileSlice estado inicial contiene las keys esperadas" name="pathsDataFileSlice estado inicial contiene las keys esperadas" time="0.002">
    </testcase>
    <testcase classname="pathsDataFileSlice getPathsDataFile.fulfilled → actualiza paths con payload.content" name="pathsDataFileSlice getPathsDataFile.fulfilled → actualiza paths con payload.content" time="0.001">
    </testcase>
    <testcase classname="pathsDataFileSlice createPathDataFile.fulfilled → reemplaza paths por payload.content" name="pathsDataFileSlice createPathDataFile.fulfilled → reemplaza paths por payload.content" time="0">
    </testcase>
    <testcase classname="pathsDataFileSlice modifyPathDataFile.fulfilled → reemplaza paths por payload.content" name="pathsDataFileSlice modifyPathDataFile.fulfilled → reemplaza paths por payload.content" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="getBorders" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.199" tests="2">
    <testcase classname="getBorders devuelve 0 si no hay style" name="getBorders devuelve 0 si no hay style" time="0.001">
    </testcase>
    <testcase classname="getBorders parsea números o strings con px" name="getBorders parsea números o strings con px" time="0">
    </testcase>
  </testsuite>
  <testsuite name="getUserRoles" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.197" tests="2">
    <testcase classname="getUserRoles devuelve ids de roles cuando existen" name="getUserRoles devuelve ids de roles cuando existen" time="0.001">
    </testcase>
    <testcase classname="getUserRoles devuelve [] cuando no hay roles" name="getUserRoles devuelve [] cuando no hay roles" time="0">
    </testcase>
  </testsuite>
  <testsuite name="icons utils" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.162" tests="2">
    <testcase classname="icons utils getIconName transforma CamelCase a kebab con prefijo en mayúsculas" name="icons utils getIconName transforma CamelCase a kebab con prefijo en mayúsculas" time="0.001">
    </testcase>
    <testcase classname="icons utils getIconVariant reemplaza el color por el variant" name="icons utils getIconVariant reemplaza el color por el variant" time="0">
    </testcase>
  </testsuite>
  <testsuite name="getRequiredFields" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.163" tests="2">
    <testcase classname="getRequiredFields arma spans con color según isFixed y omite los vacíos" name="getRequiredFields arma spans con color según isFixed y omite los vacíos" time="0.001">
    </testcase>
    <testcase classname="getRequiredFields retorna string vacío si no hay valores" name="getRequiredFields retorna string vacío si no hay valores" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="LocalStorage wrapper" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.157" tests="3">
    <testcase classname="LocalStorage wrapper set/get guardan string" name="LocalStorage wrapper set/get guardan string" time="0.001">
    </testcase>
    <testcase classname="LocalStorage wrapper setObject/getObject guardan y obtienen objeto" name="LocalStorage wrapper setObject/getObject guardan y obtienen objeto" time="0.001">
    </testcase>
    <testcase classname="LocalStorage wrapper clearKey llama removeItem y elimina la clave" name="LocalStorage wrapper clearKey llama removeItem y elimina la clave" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="utils: collections" errors="0" failures="0" skipped="0" timestamp="2025-09-26T16:10:09" time="0.143" tests="6">
    <testcase classname="utils: collections replaceItem reemplaza por id" name="utils: collections replaceItem reemplaza por id" time="0.001">
    </testcase>
    <testcase classname="utils: collections addItem agrega si trae id" name="utils: collections addItem agrega si trae id" time="0.001">
    </testcase>
    <testcase classname="utils: collections deleteItem elimina por id" name="utils: collections deleteItem elimina por id" time="0">
    </testcase>
    <testcase classname="utils: collections isEmptyValue cubre strings/obj/número/null" name="utils: collections isEmptyValue cubre strings/obj/número/null" time="0.001">
    </testcase>
    <testcase classname="utils: collections hasEmptyFields detecta vacíos en objeto" name="utils: collections hasEmptyFields detecta vacíos en objeto" time="0">
    </testcase>
    <testcase classname="utils: collections filterData filtra case-insensitive por key + value" name="utils: collections filterData filtra case-insensitive por key + value" time="0">
    </testcase>
  </testsuite>
</testsuites>